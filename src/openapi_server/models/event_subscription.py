# coding: utf-8

"""
    Nncof_EventsSubscription

    Nncof_EventsSubscription Service API.   Â© 2025, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC).   All rights reserved. 

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json




from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from openapi_server.models.event_reporting_requirement import EventReportingRequirement
from openapi_server.models.expected_analytics_type import ExpectedAnalyticsType
from openapi_server.models.nf_type import NFType
from openapi_server.models.notification_method import NotificationMethod
from openapi_server.models.nwdaf_event import NwdafEvent
from openapi_server.models.reporting_information import ReportingInformation
from openapi_server.models.snssai import Snssai
from openapi_server.models.target_ue_information import TargetUeInformation
from openapi_server.models.threshold_level import ThresholdLevel
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class EventSubscription(BaseModel):
    """
    Represents a subscription to a single event.
    """ # noqa: E501
    any_slice: Optional[StrictBool] = Field(default=None, description="\"false\" represents not applicable for all slices. \"true\" represents applicable for all slices. ", alias="anySlice")
    app_ids: Optional[Annotated[List[StrictStr], Field(min_length=1)]] = Field(default=None, description="Identification(s) of application to which the subscription applies.", alias="appIds")
    event: Optional[NwdafEvent] = None
    extra_report_req: Optional[EventReportingRequirement] = Field(default=None, alias="extraReportReq")
    notification_method: Optional[NotificationMethod] = Field(default=None, alias="notificationMethod")
    nf_load_lvl_thds: Optional[Annotated[List[ThresholdLevel], Field(min_length=1)]] = Field(default=None, description="Shall be supplied in order to start reporting when an average load level is reached. ", alias="nfLoadLvlThds")
    nf_instance_ids: Optional[List[StrictStr]] = Field(default=None, alias="nfInstanceIds")
    nf_set_ids: Optional[Annotated[List[StrictStr], Field(min_length=1)]] = Field(default=None, alias="nfSetIds")
    nf_types: Optional[Annotated[List[NFType], Field(min_length=1)]] = Field(default=None, alias="nfTypes")
    snssaia: Optional[Annotated[List[Snssai], Field(min_length=1)]] = Field(default=None, description="Identification(s) of network slice to which the subscription applies. It corresponds to snssais in the data model definition of 3GPP TS 29.520.  ")
    tgt_ue: Optional[TargetUeInformation] = Field(default=None, alias="tgtUe")
    cong_thresholds: Optional[Annotated[List[ThresholdLevel], Field(min_length=1)]] = Field(default=None, alias="congThresholds")
    expt_ana_type: Optional[ExpectedAnalyticsType] = Field(default=None, alias="exptAnaType")
    evt_req: Optional[ReportingInformation] = Field(default=None, alias="evtReq")
    __properties: ClassVar[List[str]] = ["anySlice", "appIds", "event", "extraReportReq", "notificationMethod", "nfLoadLvlThds", "nfInstanceIds", "nfSetIds", "nfTypes", "snssaia", "tgtUe", "congThresholds", "exptAnaType", "evtReq"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of EventSubscription from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of event
        if self.event:
            _dict['event'] = self.event.to_dict()
        # override the default output from pydantic by calling `to_dict()` of extra_report_req
        if self.extra_report_req:
            _dict['extraReportReq'] = self.extra_report_req.to_dict()
        # override the default output from pydantic by calling `to_dict()` of notification_method
        if self.notification_method:
            _dict['notificationMethod'] = self.notification_method.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in nf_load_lvl_thds (list)
        _items = []
        if self.nf_load_lvl_thds:
            for _item in self.nf_load_lvl_thds:
                if _item:
                    _items.append(_item.to_dict())
            _dict['nfLoadLvlThds'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in nf_types (list)
        _items = []
        if self.nf_types:
            for _item in self.nf_types:
                if _item:
                    _items.append(_item.to_dict())
            _dict['nfTypes'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in snssaia (list)
        _items = []
        if self.snssaia:
            for _item in self.snssaia:
                if _item:
                    _items.append(_item.to_dict())
            _dict['snssaia'] = _items
        # override the default output from pydantic by calling `to_dict()` of tgt_ue
        if self.tgt_ue:
            _dict['tgtUe'] = self.tgt_ue.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in cong_thresholds (list)
        _items = []
        if self.cong_thresholds:
            for _item in self.cong_thresholds:
                if _item:
                    _items.append(_item.to_dict())
            _dict['congThresholds'] = _items
        # override the default output from pydantic by calling `to_dict()` of expt_ana_type
        if self.expt_ana_type:
            _dict['exptAnaType'] = self.expt_ana_type.to_dict()
        # override the default output from pydantic by calling `to_dict()` of evt_req
        if self.evt_req:
            _dict['evtReq'] = self.evt_req.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of EventSubscription from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "anySlice": obj.get("anySlice"),
            "appIds": obj.get("appIds"),
            "event": NwdafEvent.from_dict(obj.get("event")) if obj.get("event") is not None else None,
            "extraReportReq": EventReportingRequirement.from_dict(obj.get("extraReportReq")) if obj.get("extraReportReq") is not None else None,
            "notificationMethod": NotificationMethod.from_dict(obj.get("notificationMethod")) if obj.get("notificationMethod") is not None else None,
            "nfLoadLvlThds": [ThresholdLevel.from_dict(_item) for _item in obj.get("nfLoadLvlThds")] if obj.get("nfLoadLvlThds") is not None else None,
            "nfInstanceIds": obj.get("nfInstanceIds"),
            "nfSetIds": obj.get("nfSetIds"),
            "nfTypes": [NFType.from_dict(_item) for _item in obj.get("nfTypes")] if obj.get("nfTypes") is not None else None,
            "snssaia": [Snssai.from_dict(_item) for _item in obj.get("snssaia")] if obj.get("snssaia") is not None else None,
            "tgtUe": TargetUeInformation.from_dict(obj.get("tgtUe")) if obj.get("tgtUe") is not None else None,
            "congThresholds": [ThresholdLevel.from_dict(_item) for _item in obj.get("congThresholds")] if obj.get("congThresholds") is not None else None,
            "exptAnaType": ExpectedAnalyticsType.from_dict(obj.get("exptAnaType")) if obj.get("exptAnaType") is not None else None,
            "evtReq": ReportingInformation.from_dict(obj.get("evtReq")) if obj.get("evtReq") is not None else None
        })
        return _obj


